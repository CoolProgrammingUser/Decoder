<!doctype html>
<html>
	<head>
		<title>
			Decoder
		</title>
		<base target="_blank">
		<script src="https://epicenterprograms.github.io/standards/behavior/general.js"></script>
		<script>
			var S = Standards.general;

			var telegraph = new S.Sound({ waveform: "square" });
			S.listen("morseCodeText", "dblclick", function () {
				this.value = "";
			});
			S.listen("morseCodeText", "keydown", function (event) {
				if (event.key == "Enter") {
					toMorseCode();
				}
			});
			function toMorseCode() {
				if (S.getId("morseCodeText").value.trim() != "") {
					let translation = "";
					let note = "a";
					S.getId("morseCodeText").value.toLowerCase().split("").forEach(function (character) {
						switch (character) {
							case "a":
								translation += ". -";
								break;
							case "b":
								translation += "- . . .";
								break;
							case "c":
								translation += "- . - .";
								break;
							case "d":
								translation += "- . .";
								break;
							case "e":
								translation += ".";
								break;
							case "f":
								translation += ". . - .";
								break;
							case "g":
								translation += "- - .";
								break;
							case "h":
								translation += ". . . .";
								break;
							case "i":
								translation += ". .";
								break;
							case "j":
								translation += ". - - -";
								break;
							case "k":
								translation += "- . -";
								break;
							case "l":
								translation += ". - . .";
								break;
							case "m":
								translation += "- -";
								break;
							case "n":
								translation += "- .";
								break;
							case "o":
								translation += "- - -";
								break;
							case "p":
								translation += ". - - .";
								break;
							case "q":
								translation += "- - . -";
								break;
							case "r":
								translation += ". - .";
								break;
							case "s":
								translation += ". . .";
								break;
							case "t":
								translation += "-";
								break;
							case "u":
								translation += ". . -";
								break;
							case "v":
								translation += ". . . -";
								break;
							case "w":
								translation += ". - -";
								break;
							case "x":
								translation += "- . . -";
								break;
							case "y":
								translation += "- . - -";
								break;
							case "z":
								translation += "- - . .";
								break;
							case " ":
								translation += "    ";
								break;
							case "0":
								translation += "- - - - -";
								break;
							case "1":
								translation += ". - - - -";
								break;
							case "2":
								translation += ". . - - -";
								break;
							case "3":
								translation += ". . . - -";
								break;
							case "4":
								translation += ". . . . -";
								break;
							case "5":
								translation += ". . . . .";
								break;
							case "6":
								translation += "- . . . .";
								break;
							case "7":
								translation += "- - . . .";
								break;
							case "8":
								translation += "- - - . .";
								break;
							case "9":
								translation += "- - - - .";
								break;
							case ".":
								translation += ". - . - . -";
								break;
							case "?":
								translation += ". . - - . .";
								break;
							case "!":
								translation += ["- . - . - -", "- - - ."][Math.round(Math.random())];
								break;
							case ",":
								translation += "- - . . - -";
								break;
							case "'":
								translation += ". - - - - .";
								break;
							case "(":
								translation += "- . - - .";
								break;
							case ")":
								translation += "- . - - . -";
								break;
							case ":":
								translation += "- - - . . .";
								break;
							case ";":
								translation += "- . - . - .";
								break;
							case '"':
								translation += ". - . . - .";
								break;
							case "/":
								translation += "- . . - .";
								break;
							case "+":
								translation += ". - . - .";
								break;
							case "-":
								translation += "- . . . . -";
								break;
							case "=":
								translation += "- . . . -";
								break;
							case "$":
								translation += ". . . - . . -";
								break;
							case "@":
								translation += ". - - . - .";
								break;
							case "_":
								translation += ". . - - . -";
								break;
							case "ñ":
								translation += "- - . - -";
								break;
							default:
								translation += "*";
						}
						translation += "   ";
					});
					translation = translation.replace(/\./g, note).trim();
					translation = translation.replace(/-/g, note + "--");
					translation = translation.replace(/\*/g, "a5-");
					telegraph.play(translation, { attack: 1, noteLength: 1000/S.getId("morseCodeSpeed").value, decay: 1 });
				}
			}
			S.listen("morseCodeSpeed", "dblclick", function () {
				this.value = "";
			});
			S.listen("morseCodeSpeed", "change", function () {
				this.value = this.value.trim();
				if (this.value == "" || S.getType(Number(this.value)) != "Number" || Number(this.value) < 1) {
					this.value = 15;
				}
			});
			S.listen("randomMorseCode", "click", function () {
				if (!telegraph.playing) {
					let text = S.getId("morseCodeText");
					text.value = "";
					text.value += ["I am ", "You are ", "We are ", "Morse Code is ", "This website is "][Math.floor(Math.random() * 5)];
					text.value += ["super ", "extremely ", "very ", "unmistakably ", "indisputably ", "most certainly ", "absolutely ", "without question ", "exceptionally "][Math.floor(Math.random() * 9)];
					text.value += ["amazing.", "awesome.", "cool.", "spectacular.", "sublime.", "lame. (Just kidding.)"][Math.floor(Math.random() * 6)];
					toMorseCode();
					text.value = "";
				}
			});


			S.listen("decrypted1", "dblclick", function () {
				this.value = "";
				S.getId("encrypted1").value = "";
			});
			S.listen("encrypted1", "dblclick", function () {
				this.value = "";
				S.getId("decrypted1").value = "";
			});
			S.listen("encode1", "click", function () {
				let alphabet = ["a","b","c","d","e","f","g","h","i","j","k","l","m","n","o","p","q","r","s","t","u","v","w","x","y","z"];
				let ALPHABET = ["A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V","W","X","Y","Z"];
				if (S.getId("decrypted1").value.trim() != "") {
					S.getId("encrypted1").value = S.getId("decrypted1").value.trim().replace(/\w|(?: \w)/g, function (match) {
						if (match[0] == " ") {
							if (alphabet.includes(match[1])) {
								match = String(2 * (alphabet.indexOf(match[1]) + 1));
								if (match.length < 2) {
									match = "0" + match;
								}
								match = match.splice(0, 1, match[0] == "0" ? "j" : alphabet[Number(match[0])-1]);
								match = match.splice(1, 1, match[1] == "0" ? "J" : ALPHABET[Number(match[1])-1]);
							} else if (ALPHABET.includes(match[1])) {
								match = String(2 * (ALPHABET.indexOf(match[1]) + 1));
								if (match.length < 2) {
									match = "0" + match;
								}
								match = match.splice(0, 1, match[0] == "0" ? "J" : ALPHABET[Number(match[0])-1]);
								match = match.splice(1, 1, match[1] == "0" ? "J" : ALPHABET[Number(match[1])-1]);
							}
						} else if (alphabet.includes(match)) {
							match = String(alphabet.indexOf(match) + 1);
							if (match.length < 2) {
								match = "0" + match;
							}
							match = match.splice(0, 1, match[0] == "0" ? "j" : alphabet[Number(match[0])-1]);
							match = match.splice(1, 1, match[1] == "0" ? "j" : alphabet[Number(match[1])-1]);
						} else if (ALPHABET.includes(match)) {
							match = String(ALPHABET.indexOf(match) + 1);
							if (match.length < 2) {
								match = "0" + match;
							}
							match = match.splice(0, 1, match[0] == "0" ? "J" : ALPHABET[Number(match[0])-1]);
							match = match.splice(1, 1, match[1] == "0" ? "j" : alphabet[Number(match[1])-1]);
						}
						return match;
					});
				} else if (S.getId("encrypted1").value.trim() != "") {
					S.getId("decrypted1").value = S.getId("encrypted1").value.trim().replace(/\w\w/g, function (match) {
						if (alphabet.includes(match[0])) {  // not a capital
							if (alphabet.includes(match[1])) {  // not preceded by a space
								match = match.splice(0, 1, match[0] == "j" ? "0" : String(alphabet.indexOf(match[0]) + 1));
								match = match.splice(1, 1, match[1] == "j" ? "0" : String(alphabet.indexOf(match[1]) + 1));
								match = alphabet[Number(match) - 1];
							} else if (ALPHABET.includes(match[1])) {  // preceded by a space
								match = match.splice(0, 1, match[0] == "j" ? "0" : String(alphabet.indexOf(match[0]) + 1));
								match = match.splice(1, 1, match[1] == "J" ? "0" : String(ALPHABET.indexOf(match[1]) + 1));
								match = " " + alphabet[Number(match) / 2 - 1];
							}
						} else if (ALPHABET.includes(match[0])) {  // a capital
							if (alphabet.includes(match[1])) {  // not preceded by a space
								match = match.splice(0, 1, match[0] == "J" ? "0" : String(ALPHABET.indexOf(match[0]) + 1));
								match = match.splice(1, 1, match[1] == "j" ? "0" : String(alphabet.indexOf(match[1]) + 1));
								match = ALPHABET[Number(match) - 1];
							} else if (ALPHABET.includes(match[1])) {  // preceded by a space
								match = match.splice(0, 1, match[0] == "J" ? "0" : String(ALPHABET.indexOf(match[0]) + 1));
								match = match.splice(1, 1, match[1] == "J" ? "0" : String(ALPHABET.indexOf(match[1]) + 1));
								match = " " + ALPHABET[Number(match) / 2 - 1];
							}
						}
						return match;
					});
				}
			});


			S.listen("decrypted2", "dblclick", function () {
				this.value = "";
				S.getId("encrypted2").value = "";
			});
			S.listen("encrypted2", "dblclick", function () {
				this.value = "";
				S.getId("decrypted2").value = "";
			});
			S.listen("encode2", "click", function () {
				if (S.getId("encryptionKey").value.trim() != "") {
					let key = S.getId("encryptionKey").value.trim();
					let keyIndex = 0;
					let text = "";
					if (S.getId("decrypted2").value.trim() != "") {
						let message = S.getId("decrypted2").value.trim();
						if (message[0] != " ") {
							message = " " + message;
						}
						message = message.replace(/[A-Z]/g, function (capital) {
							return " " + capital.toLowerCase();
						});
						message = message.replace(/ [a-z]/g, function (word) {
							return word[1].toUpperCase();
						});
						S.forEach(message, function (character) {
							let number = character.codePointAt(0) + key.codePointAt(keyIndex);
							if (number > 580 - 325 || number < 512 - 325) {
								text += String.fromCodePoint(127900 + number);
							} else {
								text += String.fromCodePoint(128000 + number + 325);
							}
							keyIndex++;
							if (keyIndex >= key.length) {
								keyIndex = 0;
							}
						});
						S.getId("encrypted2").value = text;
					} else if (S.getId("encrypted2").value.trim() != "") {
						let message = S.getId("encrypted2").value.trim();
						S.forEach(message.length / 2, function (number) {
							let codePoint = (message[message.length - number * 2] + message[message.length - number * 2 + 1]).codePointAt(0);
							if (codePoint < 128512 || codePoint > 128580) {
								codePoint -= 127900;
							} else {
								codePoint -= 128325;
							}
							codePoint -= key.codePointAt(keyIndex);
							if (codePoint < 0) {
								codePoint = 0;
							}
							text += String.fromCodePoint(codePoint);
							keyIndex++;
							if (keyIndex >= key.length) {
								keyIndex = 0;
							}
						});
						text = text.replace(/[A-Z]/g, function (capital) {
							return " " + capital.toLowerCase();
						});
						text = text.replace(/  [a-z]/g, function (word) {
							return " " + word[2].toUpperCase();
						});
						if (text[0] == " ") {
							text = text.slice(1);
						}
						S.getId("decrypted2").value = text;
					}
				} else {
					S.makeDialog("A password is required.");
				}
			});


			var symbols = [];
			var symbol = [];
			var drawASymbol = function () { };
			S.listen("decrypted3", "dblclick", function () {
				symbols = [];
				this.value = "";
				S.getId("encrypted3").innerHTML = "";
			});
			S.listen("encode3", "click", function () {
				if (S.getId("decrypted3").value.trim() != "") {
					S.getId("encrypted3").innerHTML = "";
					symbols = [];
					let message = S.getId("decrypted3").value;
					message = message.replace(/ +/g, " ");  // prevents more than one space at a time
					message = message.replace(/(\W)I(\W)/g, function (match, nonletter1, nonletter2) {  // uncapitalizes the word "I"
						return nonletter1 + "i" + nonletter2;
					});
					message = message.replace(/(?:^|\. )[A-Z](?!=[A-Z])/g, function (match) {  // uncapitalizes letters at the beginning of sentences
						return match.toLowerCase();
					});
					message = message.replace(/(,|\.|\?|!|:|;|\)|\/|"|]|}) (\w)/g, function (match, punctuation, letter) {  // removes spacing between punctuation & letters
						return punctuation + letter;
					});
					message = message.trim();
					let sh = Number(S.getId("symbolSize").value);  // symbol height
					let bu = sh / 4;  // base unit
					let hlw = bu / 6; // half line width (helps with padding the canvas to prevent lines from being cut in half at the edges)
					let u2 = bu * 2;  // 2 units
					let u3 = bu * 3;  // 3 units
					let u4 = bu * 4;  // 4 units
					function setSizes() {
						sh = Number(S.getId("symbolSize").value);
						bu = sh / 4;
						hlw = bu / 6;
						u2 = bu * 2;
						u3 = bu * 3;
						u4 = bu * 4;
					}
					let odd = true;
					let components = { gl: 0, dl: 0, va: 0, ha: 0, c: 0 };  // grid line, diagonal line, vertical arch, horizontal arch, circle
					function getDimensions(type, size, variation) {
						switch (type) {
							case "gl":
								if (size == "biggest") {
									if (variation) {
										return [0, 4];
									} else {
										return [4, 0];
									}
								} else if (size == "big") {
									if (variation) {
										return [0, 3];
									} else {
										return [3, 0];
									}
								} else {
									if (variation) {
										return [0, 1];
									} else {
										return [1, 0];
									}
								}
								break;
							case "dl":
								if (size == "biggest") {
									if (variation) {
										return [4, -4];
									} else {
										return [4, 4];
									}
								} else if (size == "big") {
									if (variation) {
										return [3, -3];
									} else {
										return [3, 3];
									}
								} else {
									if (variation) {
										return [1, -1];
									} else {
										return [1, 1];
									}
								}
								break;
							case "va":
								if (size == "biggest") {
									if (variation) {
										return [4, 4];
									} else {
										return [4, -4];
									}
								} else if (size == "big") {
									if (variation) {
										return [3, 3];
									} else {
										return [3, -3];
									}
								} else {
									if (variation) {
										return [1, 1];
									} else {
										return [1, -1];
									}
								}
								break;
							case "ha":
								if (size == "biggest") {
									if (variation) {
										return [4, 4];
									} else {
										return [-4, 4];
									}
								} else if (size == "big") {
									if (variation) {
										return [3, 3];
									} else {
										return [-3, 3];
									}
								} else {
									if (variation) {
										return [1, 1];
									} else {
										return [-1, 1];
									}
								}
								break;
							case "c":
								if (size == "biggest") {
									if (variation) {
										return [4, 4];
									} else {
										return [1 / 3, 1 / 3];
									}
								} else if (size == "big") {
									if (variation) {
										return [3, 3];
									} else {
										return [1 / 3, 1 / 3];
									}
								} else {
									return [1, 1];
								}
								break;
							default:
								throw new TypeError("A symbol component had an unrecognized type.");
						}
					}
					function drawSymbol(symbolToReplace, indexToReplace) {
						let currentSymbol = JSON.parse(JSON.stringify(symbol));  // prevents changing the coordinates of the actual symbol
						let canvas = document.createElement("canvas");
						let c = canvas.getContext("2d");
						let minX = 2 * sh + 2 * hlw;
						let maxX = 0;
						setSizes();  // allows changing the symbol size
						S.forEach(currentSymbol, function (component) {  // converts the symbol coordinates from unit values to actual values
							component.coords = [hlw + component.coords[0] * bu, hlw + component.coords[1] * bu];
						});
						S.forEach(currentSymbol, function (component) {  // determines the smallest x-value used in the symbol
							let width = getDimensions(component.type, component.size, component.variation)[0] * bu;
							if (width < 0) {
								if (component.coords[0] + width < minX) {
									minX = component.coords[0] + width;
								}
							} else {
								if (component.coords[0] < minX) {
									minX = component.coords[0];
								}
							}
						});
						if (minX > hlw) {  // shifts the symbol components to the left edge of the canvas
							S.forEach(currentSymbol, function (component) {
								component.coords[0] = component.coords[0] - minX + hlw;
							});
						}
						S.forEach(currentSymbol, function (component) {  // determines the largest x-value used in the symbol
							let width = getDimensions(component.type, component.size, component.variation)[0] * bu;
							if (width < 0) {
								width = 0;
							}
							if (component.coords[0] + width > maxX) {
								maxX = component.coords[0] + width;
							}
						});
						c.canvas.width = maxX + hlw;  // makes the canvas width as big as the symbol
						c.canvas.height = sh + 2 * hlw;
						c.beginPath();
						c.lineWidth = 2 * hlw;
						c.lineCap = "round";
						S.forEach(currentSymbol, function (component) {
							switch (component.type) {
								case "gl":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0], component.coords[1] + u4);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u4, component.coords[1]);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0], component.coords[1] + u3);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u3, component.coords[1]);
										}
									} else {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0], component.coords[1] + bu);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + bu, component.coords[1]);
										}
									}
									break;
								case "dl":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u4, component.coords[1] - u4);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u4, component.coords[1] + u4);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u3, component.coords[1] - u3);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + u3, component.coords[1] + u3);
										}
									} else {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + bu, component.coords[1] - bu);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.lineTo(component.coords[0] + bu, component.coords[1] + bu);
										}
									}
									break;
								case "va":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] + u4 * 1.333,
												component.coords[0] + u4, component.coords[1] + u4 * 1.333,
												component.coords[0] + u4, component.coords[1]
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] - u4 * 1.333,
												component.coords[0] + u4, component.coords[1] - u4 * 1.333,
												component.coords[0] + u4, component.coords[1]
											);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] + u4,
												component.coords[0] + u3, component.coords[1] + u4,
												component.coords[0] + u3, component.coords[1]
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] - u4,
												component.coords[0] + u3, component.coords[1] - u4,
												component.coords[0] + u3, component.coords[1]
											);
										}
									} else {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] + bu * 1.333,
												component.coords[0] + bu, component.coords[1] + bu * 1.333,
												component.coords[0] + bu, component.coords[1]
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0], component.coords[1] - bu * 1.333,
												component.coords[0] + bu, component.coords[1] - bu * 1.333,
												component.coords[0] + bu, component.coords[1]
											);
										}
									}
									break;
								case "ha":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] + u4 * 1.333, component.coords[1],
												component.coords[0] + u4 * 1.333, component.coords[1] + u4,
												component.coords[0], component.coords[1] + u4
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] - u4 * 1.333, component.coords[1],
												component.coords[0] - u4 * 1.333, component.coords[1] + u4,
												component.coords[0], component.coords[1] + u4
											);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] + u4, component.coords[1],
												component.coords[0] + u4, component.coords[1] + u3,
												component.coords[0], component.coords[1] + u3
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] - u4, component.coords[1],
												component.coords[0] - u4, component.coords[1] + u3,
												component.coords[0], component.coords[1] + u3
											);
										}
									} else {
										if (component.variation) {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] + bu * 1.333, component.coords[1],
												component.coords[0] + bu * 1.333, component.coords[1] + bu,
												component.coords[0], component.coords[1] + bu
											);
										} else {
											c.moveTo(component.coords[0], component.coords[1]);
											c.bezierCurveTo(
												component.coords[0] - bu * 1.333, component.coords[1],
												component.coords[0] - bu * 1.333, component.coords[1] + bu,
												component.coords[0], component.coords[1] + bu
											);
										}
									}
									break;
								case "c":
									if (component.size == "biggest") {
										if (component.variation) {
											c.moveTo(component.coords[0] + u4, component.coords[1] + u2);
											c.arc(component.coords[0] + u2, component.coords[1] + u2, u2, 0, 2 * Math.PI);
										} else {
											c.moveTo(component.coords[0] + 2 * hlw, component.coords[1] + hlw);
											c.arc(component.coords[0] + hlw, component.coords[1] + hlw, hlw, 0, 2 * Math.PI);
										}
									} else if (component.size == "big") {
										if (component.variation) {
											c.moveTo(component.coords[0] + u3, component.coords[1] + 1.5 * bu);
											c.arc(component.coords[0] + bu * 1.5, component.coords[1] + bu * 1.5, bu * 1.5, 0, 2 * Math.PI);
										} else {
											c.moveTo(component.coords[0] + 2 * hlw, component.coords[1] + hlw);
											c.arc(component.coords[0] + hlw, component.coords[1] + hlw, hlw, 0, 2 * Math.PI);
										}
									} else {
										c.moveTo(component.coords[0] + bu, component.coords[1] + bu / 2);
										c.arc(component.coords[0] + bu / 2, component.coords[1] + bu / 2, bu / 2, 0, 2 * Math.PI);
									}
									break;
								default:
									throw new TypeError("A symbol component had an unrecognized type.");
							}
						});
						c.stroke()
						let img = document.createElement("img");
						img.src = canvas.toDataURL();
						if (symbolToReplace) {
							S.insertAfter(img, symbolToReplace);
							S.removeSelf(symbolToReplace);
						} else {
							S.getId("encrypted3").appendChild(img);
						}
						currentSymbol = symbol;
						let currentIndex;
						if (indexToReplace === undefined) {
							currentIndex = symbols.length - 1;
						} else {
							currentIndex = indexToReplace;
						}
						img.addEventListener("click", function () {
							odd = true;
							createSubsymbol(currentSymbol, img, currentIndex);
						});
					}
					drawASymbol = drawSymbol;
					function createSubsymbol(character, symbolToReplace, indexToReplace) {
						components = { gl: 0, dl: 0, va: 0, ha: 0, c: 0 };
						if (odd) {
							symbol = [];
						}
						if (character === null) {  // if a capital subsymbol should be made
							components.gl = 1;
							components.c = 2;
						} else if (S.getType(character) == "String") {
							switch (character) {
								case " ":
									components.gl = 1;
									break;
								case "a":
									components.ha = 1;
									break;
								case "b":
									components.gl = 2;
									components.ha = 1;
									break;
								case "c":
									components.dl = 1;
									components.c = 1;
									break;
								case "d":
									components.dl = 2;
									break;
								case "e":
									components.dl = 1;
									break;
								case "f":
									components.gl = 3;
									break;
								case "g":
									components.ha = 2;
									break;
								case "h":
									components.gl = 1;
									components.ha = 1;
									break;
								case "i":
									components.gl = 2;
									break;
								case "j":
									components.gl = 1;
									components.dl = 1;
									components.ha = 1;
									break;
								case "k":
									components.gl = 2;
									components.c = 1;
									break;
								case "l":
									components.dl = 1;
									components.va = 1;
									break;
								case "m":
									components.va = 2;
									break;
								case "n":
									components.gl = 1;
									components.dl = 1;
									break;
								case "o":
									components.c = 1;
									break;
								case "p":
									components.c = 2;
									break;
								case "q":
									components.gl = 1;
									components.va = 2;
									break;
								case "r":
									components.gl = 1;
									components.c = 1;
									break;
								case "s":
									components.gl = 1;
									components.va = 1;
									break;
								case "t":
									components.va = 1;
									break;
								case "u":
									components.dl = 1;
									components.ha = 1;
									break;
								case "v":
									components.gl = 1;
									components.dl = 2;
									break;
								case "w":
									components.gl = 2;
									components.dl = 1;
									break;
								case "x":
									components.gl = 1;
									components.dl = 1;
									components.va = 1;
									break;
								case "y":
									components.gl = 2;
									components.va = 1;
									break;
								case "z":
									components.gl = 1;
									components.ha = 2;
									break;
								case ".":
									components.dl = 3;
									break;
								case ",":
									components.dl = 2;
									components.va = 1;
									break;
								case "'":
									components.dl = 2;
									components.ha = 1;
									break;
								case "?":
									components.dl = 2;
									components.c = 1;
									break;
								case "(":
									components.dl = 1;
									components.va = 2;
									break;
								case ")":
									components.va = 3;
									break;
								case "!":
									components.gl = 1;
									components.dl = 1;
									components.c = 1;
									break;
								case ":":
									components.dl = 1;
									components.c = 2;
									break;
								case ";":
									components.dl = 1;
									components.ha = 2;
									break;
								case "-":
									components.c = 3;
									break;
								case "/":
									components.ha = 3;
									break;
								case '"':
									components.gl = 5;
									break;
								case "0":
									components.gl = 2;
									components.vl = 2;
									break;
								case "1":
									components.gl = 4;
									break;
								case "2":
									components.gl = 3;
									components.dl = 1;
									break;
								case "3":
									components.gl = 3;
									components.va = 1;
									break;
								case "4":
									components.gl = 3;
									components.ha = 1;
									break;
								case "5":
									components.gl = 3;
									components.c = 1;
									break;
								case "6":
									components.gl = 2;
									components.dl = 2;
									break;
								case "7":
									components.gl = 2;
									components.dl = 1;
									components.va = 1;
									break;
								case "8":
									components.gl = 2;
									components.dl = 1;
									components.ha = 1;
									break;
								case "9":
									components.gl = 2;
									components.dl = 1;
									components.c = 1;
									break;
								default:
									components.gl = 5;
							}
						} else if (S.getType(character) == "Array") {
							if (odd) {
								S.forEach(character, function (component) {
									if (component.size != "small") {
										components[component.type] += 1;
									}
								});
							} else {
								S.forEach(character, function (component) {
									if (component.size == "small") {
										components[component.type] += 1;
									}
								});
							}
						} else {
							throw new TypeError("The character provided was an incorrect type.");
						}
						S.forEach(components, function (amount, type) {
							if (amount > 0) {
								S.forEach(amount, function () {
									let component = {};
									component.type = type;
									if (odd) {
										if (Math.round(Math.random())) {
											component.size = "big";
										} else {
											component.size = "biggest";
										}
									} else {
										component.size = "small";
									}
									component.variation = Math.round(Math.random());
									let dimensions = getDimensions(component.type, component.size, component.variation);
									let width = dimensions[0];
									let height = dimensions[1];
									let wr = 0;  // wiggle room
									if (-1 <= width && width <= 1) {
										wr = 1;
									} else {
										wr = 2;
									}
									if (width >= 0) {
										if (height >= 0) {
											component.coords = [
												Math.round((9 - width) * Math.random()),
												Math.round((4 - height) * Math.random())
											];
											if (component.coords[0] > 4 + wr - width) {
												component.coords = [
													Math.round((9 - width) * Math.random()),
													Math.round((4 - height) * Math.random())
												];
											}
											if (component.coords[0] > 4 + wr + 1 - width) {
												component.coords = [
													Math.round((9 - width) * Math.random()),
													Math.round((4 - height) * Math.random())
												];
											}
										} else {
											component.coords = [
												Math.round((9 - width) * Math.random()),
												Math.round((4 + height) * Math.random() - height)
											];
											if (component.coords[0] > 4 + wr - width) {
												component.coords = [
													Math.round((9 - width) * Math.random()),
													Math.round((4 + height) * Math.random() - height)
												];
											}
											if (component.coords[0] > 4 + wr + 1 - width) {
												component.coords = [
													Math.round((9 - width) * Math.random()),
													Math.round((4 + height) * Math.random() - height)
												];
											}
										}
									} else {
										if (height >= 0) {
											component.coords = [
												Math.round((9 + width) * Math.random() - width),
												Math.round((4 - height) * Math.random())
											];
											if (component.coords[0] > 4 + wr) {
												component.coords = [
													Math.round((9 + width) * Math.random() - width),
													Math.round((4 - height) * Math.random())
												];
											}
											if (component.coords[0] > 4 + wr + 1) {
												component.coords = [
													Math.round((9 + width) * Math.random() - width),
													Math.round((4 - height) * Math.random())
												];
											}
										} else {
											component.coords = [
												Math.round((9 + width) * Math.random() - width),
												Math.round((4 + height) * Math.random() - height)
											];
											if (component.coords[0] > 4 + wr) {
												component.coords = [
													Math.round((9 + width) * Math.random() - width),
													Math.round((4 + height) * Math.random() - height)
												];
											}
											if (component.coords[0] > 4 + wr + 1) {
												component.coords = [
													Math.round((9 + width) * Math.random() - width),
													Math.round((4 + height) * Math.random() - height)
												];
											}
										}
									}
									symbol.push(component);
								});
							}
						});
						if (!odd) {
							if (indexToReplace === undefined) {
								symbols.push(symbol);
							} else {
								symbols[indexToReplace] = symbol;
							}
							drawSymbol(symbolToReplace, indexToReplace);
							odd = !odd;
						} else if (S.getType(character) == "Array") {
							odd = !odd;
							createSubsymbol(character, symbolToReplace, indexToReplace);
						} else {
							odd = !odd;
						}
					}
					S.forEach(message, function (character) {
						if (character.search(/[A-Z]/) > -1) {  // if it's a capital
							createSubsymbol(null);
							createSubsymbol(character.toLowerCase());
						} else {
							createSubsymbol(character);
						}
					});
					if (!odd) {
						symbols.push(symbol);
						drawSymbol();
					}
				}
			});
			S.listen("symbolSize", "change", function () {
				S.forEach(S.getId("encrypted3").getElementsByTagName("img"), function (img, index) {
					symbol = symbols[index];
					drawASymbol(img, index);
				});
			});

			S.onKeyDown("Enter", function () {
				switch (document.activeElement) {
					case S.getId("morseCodeText"):
						toMorseCode();
						break;
					case S.getId("decrypted1"):
						S.getId("encode1").click();
						break;
					case S.getId("encrypted1"):
						S.getId("encode1").click();
						break;
					case S.getId("decrypted2"):
						S.getId("encode2").click();
						break;
					case S.getId("encrypted2"):
						S.getId("encode2").click();
						break;
					case S.getId("decrypted3"):
						S.getId("encode3").click();
						break;
				}
			});

			S.onLoad(function () {
				S.makeToneGenerator(true);
			});
		</script>
		<link rel="stylesheet" href="https://epicenterprograms.github.io/standards/formatting/foundation.css">
		<style>
			#morseCodeSpeed {
				width: 2em;
			}
			#encrypted3 {
				border: .05em solid black;
				padding: .5em;
				width: 15em;
				height: 9em;
				text-align: left;
				overflow: auto;
			}
			#encrypted3 img, #encrypted3 canvas {
				display: inline;
				margin: .25em .5em;
			}
		</style>
	</head>
	<body>
		<h1 class="main-title">
			Extras
		</h1>
		<main>
			<button onclick='window.location.href = "."'>
				Back
			</button>
			<section>
				Maybe you've come here in a desperate attempt to find a way of getting around the short-comings of the main decoder or maybe you were just curious after the decoder did its job; regardless, this is primarily just a place for random code-related fun. Feel free to explore.
			</section>
			<h2>
				Morse Code
			</h2>
			<input type="text" id="morseCodeText">
			<button onclick="toMorseCode()">
				Translate to Morse Code
			</button>
			Speed:
			<input type="text" id="morseCodeSpeed" value="15">
			<br>
			<button id="randomMorseCode">
				Make a random message in Morse Code
			</button>
			<h2>
				Code generators
			</h2>
			<section>
				The following sections can be used to convert text into various codes. In places where the encrypted section is editable, code can be put in, and decrypted text will be the output. Pressing "Enter" on a keyboard while having an input selected will function the same as pressing the "Encode" buttons. Double-clicking on an input will erase both the decrypted and encrypted text.
			</section>
			<h3>
				Password-protected encryption
			</h3>
			<input type="text" id="encryptionKey" placeholder="password">
			<br>
			<textarea id="decrypted2" placeholder="Decoded text"></textarea>
			<textarea id="encrypted2" placeholder="Encoded text"></textarea>
			<br>
			<button id="encode2">
				Encode
			</button>
			<h3>
				Letter code
			</h3>
			<textarea id="decrypted1" placeholder="Encode"></textarea>
			<button id="encode1">
				Encode
			</button>
			<textarea id="encrypted1" placeholder="Decode"></textarea>
			<h3>
				Symbol code
			</h3>
			<section>
				This can change text into seemingly random symbols. Pressing "Encode" multiple times will give different symbols. The symbols in the output are pictures and can be saved and used elsewhere. (Maximum symbol size is recommended if the pictures will ever be enlarged.) Due to the extreme complexity of preventing such an occurrence, there will undoubtedly be times when parts of a symbol overlap with themselves or the symbol is awkwardly arranged; As a means of combating this, it's possible to click on the undesirable symbol to rearrange its parts. There are no decoding capabilities at present because no one has time for image-recognition software. Sometimes, the symbol area randomly disappears when changing individual symbols at a large symbol-size; This can be corrected by changing the symbol size (and changing it back).
			</section>
			<textarea id="decrypted3" placeholder="Text"></textarea>
			<button id="encode3">
				Encode
			</button>
			<div id="encrypted3"></div>
			<br>
			Symbol size: <div style="background:#cccccc; border-radius:.25em"><input type="range" id="symbolSize" min="6" max="90" step="6" value="24"></div>
		</main>
	</body>
</html>
